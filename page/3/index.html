<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Ron的BLOG">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Ron的BLOG">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Ron">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Ron的BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ron的BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/11/23/711-Cowboy_Handlers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ron">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ron的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/11/23/711-Cowboy_Handlers/" class="post-title-link" itemprop="url">[翻译][erlang]cowboy handler模块的使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-11-23 20:00:00" itemprop="dateCreated datePublished" datetime="2016-11-23T20:00:00+08:00">2016-11-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="关于Cowboy"><a href="#关于Cowboy" class="headerlink" title="关于Cowboy"></a>关于Cowboy</h3><p>Cowboy是基于Erlang实现的一个轻量级、快速、模块化的http web服务器。</p>
<h3 id="Handlers"><a href="#Handlers" class="headerlink" title="Handlers"></a>Handlers</h3><p>用于处理HTTP请求的程序处理模块。</p>
<h3 id="Plain-HTTP-Handlers（常规Handlers）"><a href="#Plain-HTTP-Handlers（常规Handlers）" class="headerlink" title="Plain HTTP Handlers（常规Handlers）"></a>Plain HTTP Handlers（常规Handlers）</h3><p>Cowboy里面的handler最基础的事情就是实现 <code>init/2</code> 回调函数，处理请求，发送客户端响应（可选），最后返回。<br>Cowboy根据 <code>router configuration</code> （路由配置）接收请求并初始化State。<br>下面是一个不做任何处理的handler：</p>
<pre><code>init(Req, State) -&gt;
    &#123;ok, Req, State&#125;
</code></pre>
<p>Cowboy为了保证每一个相应都能有客户端响应，尽管上面例子没有发送客户端返回，客户端仍然会收到一个 <code>204 No Content</code> 的响应。</p>
<p>下面是一个有返回响应的例子：</p>
<pre><code>init(Req0, State) -&gt;
    Req = cowboy_req:reply(200, [
        &#123;&lt;&lt;&quot;content-type&quot;&gt;&gt;, &lt;&lt;&quot;text/plain&quot;&gt;&gt;&#125;
    ], &lt;&lt;&quot;Hello, World!&quot;&gt;&gt;, Req0),
    &#123;ok, Req, State&#125;.
</code></pre>
<p>当调用了 <code>cowboy:req/4</code>, Cowboy会马上返回一个客户端响应。</p>
<p>最后我们返回一个三元组。<code>ok</code> 表示handler允许成功，然后返回处理过后的 <code>Req</code> 给Cowboy。<br>三元组的最后一个元素是一个贯穿在handler所有回调一个state。常规的HTTP handlers一般只附加一个回调函数，<code>terminate/2</code>是一个很少使用的可选的回调函数。</p>
<h3 id="Other-Handlers（其它Handlers）"><a href="#Other-Handlers（其它Handlers）" class="headerlink" title="Other Handlers（其它Handlers）"></a>Other Handlers（其它Handlers）</h3><p><code>init/2</code> 回调函数也可以用来告诉cowboy，这是一个不同类型的handler，Cowboy应该做一些其他处理。为了方便使用，如果返回handler类型的模块名称，就可以切换handler处理模块。</p>
<p>Cowboy提供了三种可选handler类型：cowboy_reset, Cowboy_websocke和cowboy_loop。另外也可以自己定义handler类型。</p>
<p>切换非常简单，用handler类型替换掉返回的 <code>ok</code> 就可以了。下面是一个切换为 Websocket handler 的代码片段。</p>
<pre><code>init(Req, State) -&gt;
    &#123;cowboy_websocket, Req, State&#125;.
</code></pre>
<p>也可以切换到一个自定义的handler模块：</p>
<pre><code>init(Req, State) -&gt;
    &#123;my_handler_type, Req, State&#125;.
</code></pre>
<p>如何使用自定义的handler类型可以查看<code>Sub protocols</code> 章节（<a target="_blank" rel="noopener" href="https://ninenines.eu/docs/en/cowboy/2.0/guide/sub_protocols%EF%BC%89%E3%80%82">https://ninenines.eu/docs/en/cowboy/2.0/guide/sub_protocols）。</a></p>
<h3 id="Cleaning-up"><a href="#Cleaning-up" class="headerlink" title="Cleaning up"></a>Cleaning up</h3><p>除了Websocket handlers，其它所有类型都提供可选回调函数<code>terminate/3</code>：</p>
<pre><code>terminate(_Reason, _Req, _State) -&gt;
    ok.
</code></pre>
<p>这个回调函数是为了cleanup保留下来的。该函数不能发送响应给客户端。也没有其他返回值（只能返回<code>ok</code>）。</p>
<p><code>terminate/3</code>之所以是可选是因为其极少会用到。Cleanup应该在各自的进程中直接处理。（通过监控handler进程来知道其何时退出）</p>
<p>Cowboy不会在不同的请求重复使用进程（应该是http短链接设计引起的）。进程在返回之后很快就会被销毁。</p>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><p>英文官方原文：</p>
<p><a target="_blank" rel="noopener" href="https://ninenines.eu/docs/en/cowboy/2.0/guide/handlers/#_plain_http_handlers">https://ninenines.eu/docs/en/cowboy/2.0/guide/handlers/#_plain_http_handlers</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/11/23/710-Cowboy_Routing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ron">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ron的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/11/23/710-Cowboy_Routing/" class="post-title-link" itemprop="url">[翻译][erlang]cowboy路由模块使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-11-23 14:00:00" itemprop="dateCreated datePublished" datetime="2016-11-23T14:00:00+08:00">2016-11-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="关于Cowboy"><a href="#关于Cowboy" class="headerlink" title="关于Cowboy"></a>关于Cowboy</h3><p>Cowboy是基于Erlang实现的一个轻量级、快速、模块化的http web服务器。</p>
<h3 id="Routing（路由）"><a href="#Routing（路由）" class="headerlink" title="Routing（路由）"></a>Routing（路由）</h3><p>本文官方原文：<a target="_blank" rel="noopener" href="http://ninenines.eu/docs/en/cowboy/1.0/guide/routing/">http://ninenines.eu/docs/en/cowboy/1.0/guide/routing/</a></p>
<p>默认情况下，Cowboy不会做什么事情。<br>为了使Cowboy可用，需要映射URL和处理请求的Erlang模型（Module），这个过程，我们称之为路由（routing）。<br>当Cowboy接收到一个请求，通过路由，Cowboy就会尝试去匹配到相应请求的主机和资源路径。如果匹配成功，那么相关的Erlang代码就会被执行。<br>每个主机会给出相应的路由规则。Cowboy首先会匹配主机，然后尝试寻找匹配的路径。<br>在使用Cowboy之前需要先编译路由。</p>
<h3 id="Structure（结构）"><a href="#Structure（结构）" class="headerlink" title="Structure（结构）"></a>Structure（结构）</h3><p>路由一般定义成以下结构</p>
<pre><code>Routes = [Host1, Host2, ... HostN].
</code></pre>
<p>每个主机包含匹配规则（HostMatch）、限制规则（非必须）（Constraints）和一个由路径组成的路由列表（PathsList）。</p>
<pre><code>Host1 = &#123;HostMatch, PathsList&#125;.
Host2 = &#123;HostMatch, Constraints, PathsList&#125;.
</code></pre>
<p>由路径组成的路由列表与主机列表类似。</p>
<pre><code>PathsList = [Path1, Path2, ... PathN].
</code></pre>
<p>而路径（path）包含匹配路径规则、限制规则（非必须）、处理逻辑的module和会被初始化的选项参数。</p>
<pre><code>Path1 = &#123;PathMatch, Handler, Opts&#125;.
Path2 = &#123;PathMatch, Constraints, Handler, Opts&#125;.
</code></pre>
<p>下面内容为匹配语法和限制选项。</p>
<h3 id="Match-syntax（匹配语法）"><a href="#Match-syntax（匹配语法）" class="headerlink" title="Match syntax（匹配语法）"></a>Match syntax（匹配语法）</h3><p>匹配语法用来关联主机名字和相应的handler路径。<br>主机的匹配语法和路径的匹配语法类似，只有轻微的区别。譬如，他们分隔符是不一样的。而且主机是从最后开始匹配的，而路径是不是。<br>（其实说了老半天，这不就是一个普通的URL嘛。URL的前半部分为主机IP或域名，这里称之为HOST，即主机。而后半部分为路径）<br>除了特殊情况，最简单的匹配就是只有主机或者只有路径的匹配。他的值可以为string() 或binary() 类型。</p>
<pre><code>PathMatch1 = &quot;/&quot;.
PathMatch2 = &quot;/path/to/resource&quot;.
 
HostMatch1 = &quot;cowboy.example.org&quot;.
</code></pre>
<p>正如你所见，所有的路径都是由斜杠开始的。注意，下面两条路径对于路由而言是一样的。</p>
<pre><code>PathMatch2 = &quot;/path/to/resource&quot;.
PathMatch3 = &quot;/path/to/resource/&quot;.
</code></pre>
<p>而对于主机名，最后有点和没有点对于路由来说也是一样的。同样，在前面多一个点和少一个点也是一样的。</p>
<pre><code>HostMatch1 = &quot;cowboy.example.org&quot;.
HostMatch2 = &quot;cowboy.example.org.&quot;.
HostMatch3 = &quot;.cowboy.example.org&quot;.
</code></pre>
<p>因此能够提取主机和路径的数据段并且存储在Req 对象供后面使用。我们称之为值绑定。<br>绑定语法非常简单。由冒号字符（:）开头，一直到数据段的结尾的这个数据段是我们的绑定名称，会被保存。</p>
<pre><code>PathMatch = &quot;/hats/:name/prices&quot;.
HostMatch = &quot;:subdomain.example.org&quot;.
</code></pre>
<p>如果这两个最终匹配，那么就会有两个绑定定义，分布是:subdomain 和:name ，每个包含被定义的数据段。例如，这个URL地址 <a target="_blank" rel="noopener" href="http://test.example.org/hats/wild_cowboy_legendary/prices">http://test.example.org/hats/wild_cowboy_legendary/prices</a> 会将 test绑定到subdomain ,并将wild_cowboy_legendary 绑定到 name 。他们通过cowboy_req:binding&#x2F;{2,3} 函数检索出来的。绑定名字必须是原子（atom）类型。</p>
<p>还有一种特殊的绑定名字，它模仿erlang的下划线变量。任意内容都能与下划线（_）相匹配，但是数据会被丢弃。最有用的场景就是去匹配多个域名。</p>
<pre><code>HostMatch = &quot;ninenines.:_&quot;.
</code></pre>
<p>类似地，也可以添加可选内容。中括号内的内容都是可选的。</p>
<pre><code>PathMatch = &quot;/hats/[page/:number]&quot;.
HostMatch = &quot;[www.]ninenines.eu&quot;.
</code></pre>
<p>并且可选内容可以内嵌</p>
<pre><code>PathMatch = &quot;/hats/[page/[:number]]&quot;.
</code></pre>
<p>还可以使用[…] 来获取主机名或路径剩余的部分。匹配主机的时候，需要放在最前面；匹配路径的时候是放在最后面。分别使用cowboy_req:host_info&#x2F;1 和 cowboy_req:path_info&#x2F;1 函数可以找到他们。</p>
<pre><code>PathMatch = &quot;/hats/[...]&quot;.
HostMatch = &quot;[...]ninenines.eu&quot;.
</code></pre>
<p>如果一个绑定变量出现了两次，那么只有这两个位置的值相同的时候才会匹配成功。</p>
<pre><code>PathMatch = &quot;/hats/:name/:name&quot;.
</code></pre>
<p>在可选变量里面也是一样的，在下面这个例子中，如果可选变量有值，必须两个绑定变量的值都一样才可匹配到。</p>
<pre><code>PathMatch = &quot;/hats/:name/[:name]&quot;.
</code></pre>
<p>如果一个绑定变量出现在主机名和路径当中，他们需要是相同的才能匹配。</p>
<pre><code>PathMatch = &quot;/:user/[...]&quot;.
HostMatch = &quot;:user.github.com&quot;.
</code></pre>
<p>当然也有两种特殊情况，第一种使用下划线变量（_）可以匹配任意的主机名和路径。</p>
<pre><code>PathMatch = &#39;_&#39;.
HostMatch = &#39;_&#39;.
</code></pre>
<p>第二种，使用通配符星号（*）来匹配。</p>
<pre><code>HostMatch = &quot;*&quot;.
</code></pre>
<h3 id="Constraints（约束）"><a href="#Constraints（约束）" class="headerlink" title="Constraints（约束）"></a>Constraints（约束）</h3><p>关于这段没看懂，下面是英文原文：</p>
<blockquote>
<p>After the matching has completed, the resulting bindings can be tested against a set of constraints. Constraints are only tested when the binding is defined. They run in the order you defined them. The match will succeed only if they all succeed.</p>
</blockquote>
<blockquote>
<p>They are always given as a two or three elements tuple, where the first element is the name of the binding, the second element is the constraint’s name, and the optional third element is the constraint’s arguments.</p>
</blockquote>
<blockquote>
<p>The following constraints are currently defined:</p>
</blockquote>
<blockquote>
<ul>
<li>{Name, int}</li>
<li>{Name, function, fun ((Value) -&gt; true | {true, NewValue} | false)}</li>
</ul>
</blockquote>
<p>The int constraint will check if the binding is a binary string representing an integer, and if it is, will convert the value to integer.</p>
<blockquote>
<p>The function constraint will pass the binding value to a user specified function that receives the binary value as its only argument and must return whether it fulfills the constraint, optionally modifying the value. The value thus returned can be of any type.</p>
</blockquote>
<blockquote>
<p>Note that constraint functions SHOULD be pure and MUST NOT crash.</p>
</blockquote>
<h3 id="Compilation（编译-x2F-收集）"><a href="#Compilation（编译-x2F-收集）" class="headerlink" title="Compilation（编译&#x2F;收集）"></a>Compilation（编译&#x2F;收集）</h3><p>在传递给Cowboy之前，定义的结构首先要先编译。才能是Cowboy有效查找到正确的handler，并执行，而不必重复地解析路由。<br>编译通过调用cow_router:compile&#x2F;1 函数进行。</p>
<pre><code>Dispatch = cowboy_router:compile([
    %% &#123;HostMatch, list(&#123;PathMatch, Handler, Opts&#125;)&#125;
    &#123;&#39;_&#39;, [&#123;&#39;_&#39;, my_handler, []&#125;]&#125;
]),
%% Name, NbAcceptors, TransOpts, ProtoOpts
cowboy:start_http(my_http_listener, 100,
    [&#123;port, 8080&#125;],
    [&#123;env, [&#123;dispatch, Dispatch&#125;]&#125;]
).
</code></pre>
<p>注意，如果结构不正确，函数会返回{error, badarg}。</p>
<h3 id="Live-update（热更新）"><a href="#Live-update（热更新）" class="headerlink" title="Live update（热更新）"></a>Live update（热更新）</h3><p>使用cowboy:set_env&#x2F;3 函数可以更新当前的路由列表。这会应用到所有的监听器中。</p>
<pre><code>cowboy:set_env(my_http_listener, dispatch,
    cowboy_router:compile(Dispatch)).
</code></pre>
<p>注意，设置之前还是需要编译的哦。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/11/01/901-Docker_Cmd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ron">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ron的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/11/01/901-Docker_Cmd/" class="post-title-link" itemprop="url">[docker]docker常用命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-11-01 17:00:00" itemprop="dateCreated datePublished" datetime="2016-11-01T17:00:00+08:00">2016-11-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="0-学习的一些疑问"><a href="#0-学习的一些疑问" class="headerlink" title="0. 学习的一些疑问"></a>0. 学习的一些疑问</h3><ul>
<li>如何热更新镜像(images)？（你可以快速启动或者销毁容器。这种时间几乎是实时的）</li>
<li>如何热更新游戏服？</li>
<li>好处在于各个应用之间环境相互独立，即使某一个容器崩溃也不会影响到其它容器；</li>
<li>每个容器使用端口如何维护？（方法1写在Dockerfile里面，不灵活；方法2在run的时候-p指定）；</li>
<li>那这样的话，会存在好多linux用户，相当于每一个容器就要维护一个物理机（虚拟）；</li>
<li>需要一套工具来管理维护镜像、容器的操作和状态；</li>
<li>目前主流使用docker都是应用到哪些场景中？</li>
</ul>
<h3 id="1-docker的二个软件"><a href="#1-docker的二个软件" class="headerlink" title="1. docker的二个软件"></a>1. docker的二个软件</h3><ul>
<li>Docker: 开源的容器虚拟化平台；</li>
<li>Docker Hub: Software-as-a-Service平台，用来共享和管理docker容器。</li>
</ul>
<h3 id="2-docker的三大模块"><a href="#2-docker的三大模块" class="headerlink" title="2. docker的三大模块"></a>2. docker的三大模块</h3><ul>
<li>Docker images.(镜像)</li>
<li>Docker registries.(仓库)</li>
<li>Docker container.(容器)</li>
</ul>
<h3 id="3-常用命令"><a href="#3-常用命令" class="headerlink" title="3. 常用命令"></a>3. 常用命令</h3><h4 id="3-1-常用镜像命令"><a href="#3-1-常用镜像命令" class="headerlink" title="3.1. 常用镜像命令"></a>3.1. 常用镜像命令</h4><ul>
<li>docker image(查看镜像信息)</li>
<li>docker build(创建镜像)<ul>
<li>Dockerfile<ul>
<li>‘#注释’</li>
<li>FROM 基于哪个镜像为基础</li>
<li>MAINTAINER 维护者信息</li>
<li>RUN 运行指令</li>
<li>ADD 复制本地文件到镜像</li>
<li>EXPOSE 设置开放端口</li>
<li>CMD 容器启动后允许的程序</li>
<li>WORKDIR 切换工作目录</li>
</ul>
</li>
<li>-t 添加tag</li>
<li>build后面需要接路径</li>
</ul>
</li>
</ul>
<h4 id="3-2-少用镜像命令"><a href="#3-2-少用镜像命令" class="headerlink" title="3.2. 少用镜像命令"></a>3.2. 少用镜像命令</h4><ul>
<li>docker pull(获取镜像)</li>
<li>docker push(上传镜像)</li>
<li>docker search(搜索镜像)<ul>
<li>-s N 只搜索指定星级以上的镜像</li>
</ul>
</li>
<li>docker rmi(删除镜像)</li>
<li>docker tag [id] [new name:tag] (修改tag)</li>
<li>docker save(保存镜像)</li>
<li>docker load(加载镜像)<ul>
<li>docker load –input xxx.tar</li>
<li>docker load &lt; xxx.tar</li>
<li>load与import的区别，镜像是完整的与快照是丢弃历史记录和元数据信息的</li>
</ul>
</li>
<li>docker rmi $(docker images -q -f “dangling&#x3D;true”)(清理所有未打过标签的本地镜像)</li>
</ul>
<h4 id="3-3-常用容器命令"><a href="#3-3-常用容器命令" class="headerlink" title="3.3. 常用容器命令"></a>3.3. 常用容器命令</h4><ul>
<li>docker run([下载镜像并]启动容器)<ul>
<li>-t 分配一个伪终端</li>
<li>-i 打开标准输入</li>
<li>-d 后台运行</li>
<li>-v <path> 创建并挂载数据卷(可有多个)</li>
<li>–volumes-from 挂载数据卷(可有多个)</li>
<li>-p 指定映射端口 (ip:Port:containerPort&#x2F;udp|ip::containerPort|port:containerPort)</li>
<li>-P 随机映射端口</li>
<li>–name 自定义容器名字</li>
<li>–rm 终止后立即删除容器</li>
<li>–link <name>:<alias> 容器互联</li>
</ul>
</li>
<li>docker start(启动已终止容器)</li>
<li>docker stop(终止容器)</li>
<li>nsenter(进入容器)(推荐)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PID=$(docker inspect --format <span class="string">&quot;&#123;&#123; .State.Pid &#125;&#125;&quot;</span> &lt;container ID&gt;)</span><br><span class="line">nsenter --target <span class="variable">$PID</span> --mount --uts --ipc --net --pid</span><br></pre></td></tr></table></figure>

<h4 id="3-4-少用容器命令"><a href="#3-4-少用容器命令" class="headerlink" title="3.4. 少用容器命令"></a>3.4. 少用容器命令</h4><ul>
<li>docker commit(提交容器)<ul>
<li>-m –massage&#x3D;”” 提交信息</li>
<li>-a –author&#x3D;”” 作者信息</li>
<li>-p –pause&#x3D;true 提交时暂停容器运行</li>
</ul>
</li>
<li>docker attach(进入容器)</li>
<li>docker ps(查看正在运行的容器)<ul>
<li>-a 查看已终止</li>
</ul>
</li>
<li>docker logs [container ID or NAMES] 查看(后台)运行日志</li>
<li>docker export(导出容器为文件)<ul>
<li>docker export <container ID> &gt; xxx.tar</li>
</ul>
</li>
<li>docker import(文件快照导入镜像)<ul>
<li>cat xxx.tar | docker import - test&#x2F;name:v1.0</li>
<li>docker import <a target="_blank" rel="noopener" href="http://xxx.tgz/">http://xxx.tgz</a> test&#x2F;name</li>
</ul>
</li>
<li>docker rm(删除容器)<ul>
<li>默认不会删除运行中的容器</li>
<li>docker rm $(docker ps -a -q) 清理所有处于终止状态的容器</li>
<li>-v 同时删除数据卷</li>
</ul>
</li>
</ul>
<h3 id="4-安装"><a href="#4-安装" class="headerlink" title="4. 安装"></a>4. 安装</h3><h3 id="4-1-在CentOS7中安装"><a href="#4-1-在CentOS7中安装" class="headerlink" title="4.1. 在CentOS7中安装"></a>4.1. 在CentOS7中安装</h3><pre><code>curl -sSL https://get.docker.com/ | sh        //下载官服脚本按照
chkconfig docker on                           //设置开机自动启动
</code></pre>
<h3 id="4-2-在CentOS6中安装"><a href="#4-2-在CentOS6中安装" class="headerlink" title="4.2. 在CentOS6中安装"></a>4.2. 在CentOS6中安装</h3><h4 id="4-2-1-添加yum软件源"><a href="#4-2-1-添加yum软件源" class="headerlink" title="4.2.1. 添加yum软件源"></a>4.2.1. 添加yum软件源</h4><pre><code>tee /etc/yum.repo.d/docker.repo &lt;&lt; &#39;EOF&#39;
[dockerrepo]
name=Docker Repository
baseurl=https://yum.dockerproject.org/repo/main/centos/$releasever/
enabled=1
gpgcheck=1
gpgkey=https://yum.dockerproject.org/gpg
EOF
</code></pre>
<h4 id="4-2-2-安装docker"><a href="#4-2-2-安装docker" class="headerlink" title="4.2.2. 安装docker"></a>4.2.2. 安装docker</h4><pre><code>yum update
yum install -y docker-engine
</code></pre>
<h4 id="4-2-3-No-module-named-yum"><a href="#4-2-3-No-module-named-yum" class="headerlink" title="4.2.3. No module named yum"></a>4.2.3. No module named yum</h4><p>如果在执行<code>yum update</code>的时候出现了<code>No module named yum</code>错误，可能是存在与yum不对应的python版本引起。可以通过修改yum和yum-updatest的执行脚本（<code>/usr/bin/yum</code>和<code>/usr/bin/yum-updatest</code>）的注释来指定python版本。譬如：</p>
<pre><code>#!/usr/bin/python
修改为
#!/usr/bin/python2.6
</code></pre>
<h3 id="5-基础环境"><a href="#5-基础环境" class="headerlink" title="5. 基础环境"></a>5. 基础环境</h3><p>可以下载bashrc_docker文件，加载到环境.bashrc中，其可以提供一些方便的命令用于做一些比较复杂的过程。</p>
<p><code>.bashrc_docker</code>(<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/yeasy/docker_practice/master/_local/.bashrc_docker">https://raw.githubusercontent.com/yeasy/docker_practice/master/_local/.bashrc_docker</a>) 定义了以下命令<br>    - docker-pid(获取容器pid)<br>    - docker-enter(进入容器)</p>
<p>下载和加载到linux环境中：</p>
<pre><code>wget -P ~ https://raw.githubusercontent.com/yeasy/docker_practice/master/_local/.bashrc_docker
echo &quot;[ -f ~/.bashrc_docker ] &amp;&amp; . ~/.bashrc_docker&quot; &gt;&gt; ~/.bashrc;source ~/.bashrc
</code></pre>
<h3 id="6-仓库"><a href="#6-仓库" class="headerlink" title="6. 仓库"></a>6. 仓库</h3><h4 id="6-1-私有仓库"><a href="#6-1-私有仓库" class="headerlink" title="6.1. 私有仓库"></a>6.1. 私有仓库</h4><p>官服提供了一个docker-registry镜像来供私有仓库的搭建。</p>
<pre><code>docker run -d -p 80:5000 registry

vi /etc/docker/daemon.json
&#123;&quot;insecure-registries&quot;:[&quot;myregistry.example.com:5000&quot;]&#125;

cul http://x.x.x.x:2010/v2/linerl/tags/list
</code></pre>
<p>API文档：<a target="_blank" rel="noopener" href="https://github.com/docker/distribution/blob/master/docs/spec/api.md">https://github.com/docker/distribution/blob/master/docs/spec/api.md</a></p>
<h3 id="7-学习后的一些结论"><a href="#7-学习后的一些结论" class="headerlink" title="7. 学习后的一些结论"></a>7. 学习后的一些结论</h3><ul>
<li>本身是虚拟机技术实现的服务器大多数带有随时可扩展升级的性质，没有资源分配的需求，没有必要用到docker；</li>
<li>docker适合在做负载均衡的短链接的web服务上面，应用场景都是以镜像、容器为操作单位的最佳；</li>
<li>如果有业务可以做到镜像、容器来维护就可以的，说明这个业务就很合适使用docker。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/09/22/451-ci_md_2_html/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ron">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ron的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/22/451-ci_md_2_html/" class="post-title-link" itemprop="url">[python]自动化将markdown文件转成html文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-09-22 18:00:00" itemprop="dateCreated datePublished" datetime="2016-09-22T18:00:00+08:00">2016-09-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>我们项目开发人员写的文档都是<code>markdown</code>文件。对于其它组的同学要进行阅读不是很方便。每次编辑完<code>markdown</code>文件，我都是用软件将<code>md</code>文件转成<code>html</code>文件。刚开始转的时候，还没啥，转得次数多了，就觉得不能继续这样下去了。作为一名开发人员，还是让机器去做这些琐碎的事情吧。故写了两个脚本将<code>md</code>文件转成<code>html</code>文件，并将其放置在web服务器下，方便其他人员阅读。</p>
<p>主要有两个脚本和一个定时任务：</p>
<ul>
<li>一个python脚本，主要将<code>md</code>文件转成<code>html</code>文件；</li>
<li>一个shell脚本，主要用于管理逻辑；</li>
<li>一个linux定时任务，主要是定时执行shell脚本。</li>
</ul>
<h3 id="二、用python将markdown转成html"><a href="#二、用python将markdown转成html" class="headerlink" title="二、用python将markdown转成html"></a>二、用python将markdown转成html</h3><h4 id="2-1-python依赖库"><a href="#2-1-python依赖库" class="headerlink" title="2.1 python依赖库"></a>2.1 python依赖库</h4><p>使用python的markdown库来转换md文件到html依赖两个库：</p>
<ul>
<li>pip install markdown</li>
<li>pip install importlib</li>
</ul>
<h4 id="2-2-核心代码"><a href="#2-2-核心代码" class="headerlink" title="2.2 核心代码"></a>2.2 核心代码</h4><p>核心代码其实只有一句，执行 <code>markdown.markdown(text)</code>就可以获得生成的html的原文。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input_file = codecs.<span class="built_in">open</span>(in_file, mode=<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">text = input_file.read()</span><br><span class="line">html = markdown.markdown(text)</span><br></pre></td></tr></table></figure>

<h4 id="2-3-html编码和html样式"><a href="#2-3-html编码和html样式" class="headerlink" title="2.3 html编码和html样式"></a>2.3 html编码和html样式</h4><p>直接<code>markdown.markdown(text)</code>生成的html文本，非常粗略，只是单纯的html内容。而且在浏览器内查看的时候中文乱码(在chrome中)，没有好看的css样式，太丑了。</p>
<p><img src="/pics/451_luanma.png" alt="乱码无样式"></p>
<p>解决办法也很简单，在保存文件的时候，将<code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</code>和css样式添加上。就这么简单解决了。</p>
<p><img src="/pics/451_piaoliang.png" alt="带css样式"></p>
<h4 id="2-4-完整python内容"><a href="#2-4-完整python内容" class="headerlink" title="2.4 完整python内容"></a>2.4 完整python内容</h4><ul>
<li>读取md文件；</li>
<li>将md文件转成html文本；</li>
<li>添加css样式和保存html文本。</li>
</ul>
<p>python代码内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 使用方法 python markdown_convert.py filename</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> markdown</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">css = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span></span><br><span class="line"><span class="string">&lt;style type=&quot;text/css&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;!-- 此处省略掉markdown的css样式，因为太长了 --&gt;</span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">    name = argv[<span class="number">0</span>]</span><br><span class="line">    in_file = <span class="string">&#x27;%s.md&#x27;</span> % (name)</span><br><span class="line">    out_file = <span class="string">&#x27;%s.html&#x27;</span> % (name)</span><br><span class="line"></span><br><span class="line">    input_file = codecs.<span class="built_in">open</span>(in_file, mode=<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    text = input_file.read()</span><br><span class="line">    html = markdown.markdown(text)</span><br><span class="line"></span><br><span class="line">    output_file = codecs.<span class="built_in">open</span>(out_file, <span class="string">&quot;w&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>,errors=<span class="string">&quot;xmlcharrefreplace&quot;</span>)</span><br><span class="line">    output_file.write(css+html)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">   main(sys.argv[<span class="number">1</span>:])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="三、shell逻辑"><a href="#三、shell逻辑" class="headerlink" title="三、shell逻辑"></a>三、shell逻辑</h3><h4 id="3-1-逻辑说明"><a href="#3-1-逻辑说明" class="headerlink" title="3.1 逻辑说明"></a>3.1 逻辑说明</h4><p>建立一个shell文件，用于进行逻辑处理，主要操作如下：</p>
<ul>
<li>更新svn文件，将最新的md文件更新下来(此处假设md文件是<code>测试文档.md</code>)；</li>
<li>执行<code>python markdown_convert.py $NAME</code>将md文件转成html文件(生成<code>测试文档.html</code>)；</li>
<li>将转好的html迁移到web路径下(移动到<code>html/测试文档.html</code>)；</li>
<li>启动一个web服务(此处用的是python的<code>SimpleHTTPServer</code>的web服务器).</li>
</ul>
<h4 id="3-2-完整shell逻辑"><a href="#3-2-完整shell逻辑" class="headerlink" title="3.2 完整shell逻辑"></a>3.2 完整shell逻辑</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">NAME=<span class="string">&#x27;测试文档&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 更新代码</span></span><br><span class="line">svn update</span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除html文件</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$NAME</span>.html&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">    rm <span class="string">&quot;<span class="variable">$NAME</span>.html&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 生成html</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$NAME</span>.md&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">    python markdown_convert.py <span class="variable">$NAME</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 生成html目录</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">&quot;html&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">    mkdir <span class="string">&quot;html&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 拷贝html文件</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$NAME</span>.html&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">    mv -f <span class="string">&quot;<span class="variable">$NAME</span>.html&quot;</span> <span class="string">&quot;html/&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 开启web服务器</span></span><br><span class="line">PID=`ps aux | grep <span class="string">&#x27;python -m SimpleHTTPServer 8080&#x27;</span> | grep -v <span class="string">&#x27;grep&#x27;</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$PID</span>&quot;</span> = <span class="string">&quot;&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">cd</span> html</span><br><span class="line">    nohup python -m SimpleHTTPServer 8080 &amp;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;start web server&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;already start&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="四、linux定时任务"><a href="#四、linux定时任务" class="headerlink" title="四、linux定时任务"></a>四、linux定时任务</h3><p>在shell命令下输入<code>crontab -e</code>进入<code>linux</code>定时任务编辑界面。在里面设置<code>markdown2web.sh</code>脚本的定时任务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 更新文档</span></span><br><span class="line">*/10 * * * * <span class="built_in">cd</span> /home/xxx/doc; sh markdown2web.sh &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>设置每10分钟执行一次<code>markdown2web.sh</code>脚本，当然也可以根据需求修改频率。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/03/24/701-Erlang_erlcron_crash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ron">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ron的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/03/24/701-Erlang_erlcron_crash/" class="post-title-link" itemprop="url">[erlang]一次erlcron崩溃引起的事故分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-03-24 13:34:57" itemprop="dateCreated datePublished" datetime="2016-03-24T13:34:57+08:00">2016-03-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="事故背景"><a href="#事故背景" class="headerlink" title="事故背景"></a>事故背景</h3><p>由于误操作在<code>erlcron</code>设置了一个超过3个月后的定时任务。然后第二天之后发现每天的daily reset没有被执行，一些定时任务也没有被执行。瞬间感觉整个人都不好了，怎么无端端就不执行了呢。</p>
<p>通过排查日志，发现了以下报错：</p>
<pre><code>2016-03-22 16:54:32.014 [error] gen_server ecrn_control terminated with reason: no case clause matching &#123;ok,[&lt;0.14123.1577&gt;,&lt;0.13079.1576&gt;,&lt;0.25254.1569&gt;,&lt;0.13402.1577&gt;,...]&#125; in ecrn_control:internal_cancel/1 line 111
2016-03-22 16:54:32.015 [error] CRASH REPORT Process ecrn_control with 0 neighbours exited with reason: no case clause matching &#123;ok,[&lt;0.14123.1577&gt;,&lt;0.13079.1576&gt;,&lt;0.25254.1569&gt;,&lt;0.13402.1577&gt;,...]&#125; in ecrn_control:internal_cancel/1 line 111 in gen_server:terminate/6 line 744
</code></pre>
<p>我擦，<code>ecrn_control</code>都崩了，怎么回事。</p>
<p>找到具体出错的代码：</p>
<pre><code>internal_cancel(AlarmRef) -&gt;
    case ecrn_reg:get(AlarmRef) of
        undefined -&gt;
            undefined;
        &#123;ok, [Pid]&#125; -&gt;
            ecrn_agent:cancel(Pid)
    end.
</code></pre>
<p>发现调用<code>ecrn_reg:get(AlarmRef)</code>被返回了{ok, List}，而且这个List的数据远不止一个。明显在设置那个超过3个月的定时任务的时候，<code>ecrn_reg</code>被注册进了脏数据。</p>
<h3 id="事故重现"><a href="#事故重现" class="headerlink" title="事故重现"></a>事故重现</h3><h4 id="先设置几个正常的定时任务"><a href="#先设置几个正常的定时任务" class="headerlink" title="先设置几个正常的定时任务"></a>先设置几个正常的定时任务</h4><pre><code>&gt; erlcron:cron(&#123;&#123;once, 1000&#125;, &#123;io, fwrite, ["Hello, world!~n"]&#125;&#125;).
&gt; erlcron:cron(&#123;&#123;once, 1000&#125;, &#123;io, fwrite, ["Hello, world!~n"]&#125;&#125;).
&gt; erlcron:cron(&#123;&#123;once, 1000&#125;, &#123;io, fwrite, ["Hello, world!~n"]&#125;&#125;).
</code></pre>
<p>查看<code>observer:start()</code> 可以看到进程树如下：</p>
<p><img src="http://i.imgur.com/H4oSaR0.png"></p>
<h4 id="再设置一个4294968秒之后的定时任务"><a href="#再设置一个4294968秒之后的定时任务" class="headerlink" title="再设置一个4294968秒之后的定时任务"></a>再设置一个4294968秒之后的定时任务</h4><pre><code>&gt; erlcron:cron(&#123;&#123;once, 4294968&#125;, &#123;io, fwrite, ["Hello, world!~n"]&#125;&#125;).
</code></pre>
<p>结果就gg了，好多崩溃信息是不是：</p>
<pre><code>22:49:16.818 [error] CRASH REPORT Process &lt;0.5822.64&gt; with 0 neighbours crashed with reason: timeout_value in gen_server:loop/6 line 358
22:49:16.818 [error] Supervisor ecrn_cron_sup had child ecrn_agent started with ecrn_agent:start_link(#Ref&lt;0.0.11.11209&gt;, &#123;&#123;once,4294968&#125;,&#123;io,fwrite,["Hello, world!~n"]&#125;&#125;) at &lt;0.5822.64&gt; exit with reason timeout_value in context child_terminated
22:49:16.819 [error] CRASH REPORT Process &lt;0.5701.64&gt; with 0 neighbours crashed with reason: timeout_value in gen_server:loop/6 line 358
22:49:16.821 [error] Supervisor ecrn_cron_sup had child ecrn_agent started with ecrn_agent:start_link(#Ref&lt;0.0.11.11209&gt;, &#123;&#123;once,4294968&#125;,&#123;io,fwrite,["Hello, world!~n"]&#125;&#125;) at &lt;0.5701.64&gt; exit with reason timeout_value in context child_terminated
22:49:16.821 [error] CRASH REPORT Process &lt;0.6237.64&gt; with 0 neighbours crashed with reason: timeout_value in gen_server:loop/6 line 358
22:49:16.821 [error] Supervisor ecrn_cron_sup had child ecrn_agent started with ecrn_agent:start_link(#Ref&lt;0.0.11.11209&gt;, &#123;&#123;once,4294968&#125;,&#123;io,fwrite,["Hello, world!~n"]&#125;&#125;) at &lt;0.6237.64&gt; exit with reason timeout_value in context child_terminated
22:49:16.821 [error] CRASH REPORT Process &lt;0.5862.64&gt; with 0 neighbours crashed with reason: timeout_value in gen_server:loop/6 line 358
22:49:16.821 [error] Supervisor ecrn_cron_sup had child ecrn_agent started with ecrn_agent:start_link(#Ref&lt;0.0.11.11209&gt;, &#123;&#123;once,4294968&#125;,&#123;io,fwrite,["Hello, world!~n"]&#125;&#125;) at &lt;0.5862.64&gt; exit with reason timeout_value in context child_terminated

...(总共有25条)
</code></pre>
<p>再看一下进程数：</p>
<p><img src="http://i.imgur.com/TSYo5CH.png"></p>
<p>我擦，为毛原来的 scrn_agent 进程也没有了。</p>
<p>可以发现，erlcron 在尝试了25次设置 这个定时任务之后，也就是 scrn_agent 崩溃了25次之后，原来设置的三个正常的定时任务的scrn_agent 进程也没有掉了。<br>也就是说，不但我新设置的定时任务没有成功，而且我原来正常的定时任务也没有掉了。</p>
<p>再看一下崩溃日志里面的崩掉的进程号，每一个都是不一样的。可以推算其实原来的报错<code>ecrn_reg:get(AlarmRef)</code>获取到了多个Pid，其实就是这里插入失败的定时任务产生的25个Pid。也就是说，虽然<code>ecrn_agent</code>进程崩溃了，但是<code>ecrn_reg</code>还是保存了这些Pid。所以在取消这些定时任务的时候，<code>ecrn_reg:get(AlarmRef)</code>返回的内容在<code>internal_cancel(AlarmRef)</code>没有被匹配到。</p>
<h3 id="为什么是4294968，其实是2-32"><a href="#为什么是4294968，其实是2-32" class="headerlink" title="为什么是4294968，其实是2^32"></a>为什么是4294968，其实是2^32</h3><p>为什么设置了<code>4294968</code>秒后的定时任务就崩溃了。这个数估计很多人很熟悉，<code>2^32=4294967296</code>，而<code>4294968000</code>也就是刚好大于<code>2^32</code>。即，如果设置的定时任务超过了<code>2^32</code>毫秒，在<code>erlcron</code>里面就不支持了。</p>
<p>查看<code>gen_server:loop</code>的源码，找到引起崩溃的代码：</p>
<p><img src="http://i.imgur.com/w9NJViE.png"></p>
<pre><code>loop(Parent, Name, State, Mod, hibernate, Debug) -&gt;
    proc_lib:hibernate(?MODULE,wake_hib,[Parent, Name, State, Mod, Debug]);
loop(Parent, Name, State, Mod, Time, Debug) -&gt;
    Msg = receive
          Input -&gt;
            Input
      after Time -&gt;
          timeout
      end,
    decode_msg(Msg, Parent, Name, State, Mod, Time, Debug, false).
</code></pre>
<p>可以发现引起崩溃的，358行是一段<code>receive</code>代码。也就是说<code>receive</code>是不支持超过<code>2^32</code>大小的。</p>
<p>自测了一下，的确如果<code>receive</code>的<code>after</code>后面如果是大于等于<code>2^32</code>的数值就会出现<code>bad receive timeout value</code>的报错。查看官方解释，已经明确说明不能大于<code>32位</code>大小。</p>
<blockquote>
<p>ExprT is to evaluate to an integer. The highest allowed value is 16#FFFFFFFF, that is, the value must fit in 32 bits. receive..after works exactly as receive, except that if no matching message has arrived within ExprT milliseconds, then BodyT is evaluated instead. The return value of BodyT then becomes the return value of the receive..after expression.</p>
</blockquote>
<p><em>引用自：<a target="_blank" rel="noopener" href="http://erlang.org/doc/reference_manual/expressions.html">http://erlang.org/doc/reference_manual/expressions.html</a></em></p>
<p>再回到<code>erlcron</code>， 在 <code>ecrn_agent:start_link</code>的时候，<code>ecrn_agent:init</code>执行完<code>ecrn_reg:register(JobRef, self())</code>返回<code>&#123;ok, NewState, Millis&#125;</code>到<code>gen_server</code>之后，Millis如果超过<code>2^32</code>在<code>gen_server:loop</code>就会引起<code>gen_server</code>的<code>timeout_value</code>异常退出。</p>
<pre><code>%% @private
init([JobRef, Job]) -&gt;
    State = #state&#123;job=Job,
                   alarm_ref=JobRef&#125;,
    &#123;DateTime, Actual&#125; = ecrn_control:datetime(),
    NewState = set_internal_time(State, DateTime, Actual),
    case until_next_milliseconds(NewState, Job) of
        &#123;ok, Millis&#125; when is_integer(Millis) -&gt;
            ecrn_reg:register(JobRef, self()),
            &#123;ok, NewState, Millis&#125;;
        &#123;error, _&#125;  -&gt;
            &#123;stop, normal&#125;
    end.
</code></pre>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这坑踩的，有点郁闷。其实这跟<code>erlcron</code>也没关系，也不是<code>gen_server</code>的问题。而是<code>erlang</code>自身<code>receive</code>不支持2^32引起的。继续往下查其实可以发现，再往下是其它语言写的了。</p>
<pre><code>-module(prim_eval).

%% This module is simply a stub which abstract code gets included in the result
%% of compilation of prim_eval.S, to keep Dialyzer happy.

-export([&#39;receive&#39;/2]).

-spec &#39;receive&#39;(fun((term()) -&gt; nomatch | T), timeout()) -&gt; T.
&#39;receive&#39;(_, _) -&gt;
    erlang:nif_error(stub).
</code></pre>
<p><em>与君共勉</em></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2015/11/14/601-Ftp_bat_help/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ron">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ron的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/11/14/601-Ftp_bat_help/" class="post-title-link" itemprop="url">[windows]快速从ftp下载最新软件包的批处理脚本 </a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2015-11-14 17:15:57" itemprop="dateCreated datePublished" datetime="2015-11-14T17:15:57+08:00">2015-11-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>由于敏捷开发，快速迭代，我们项目一天会有三个版本，也就意味着我一天要去获取三次软件包。我负责服务端开发，所以我经常需要去拿最新的客户端。我们的客户端放置在一个公共的ftp上面。每天频繁登陆ftp下载，或者使用ftp工具，每次都要点击同步，都不太方便。如果在linux下就好了，然而在windows也是可以运行脚本的，何不尝试下呢。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code>@echo off
rem for download file
rem ftp config 
rem ip login_name password remote_dir

set &quot;ftp_ip=192.168.0.1&quot;
set &quot;ftp_user=admin&quot;
set &quot;ftp_pass=123456&quot;
set &quot;ftp_path=/&quot;

set &quot;f_tmp=tmp&quot;
set &quot;f_info=tmp\tmp_info.dat&quot;
set &quot;f_list=tmp\tmp_list.dat&quot;

rd /s /q pack
mkdir %f_tmp%

echo open %ftp_ip% &gt; %f_info%
echo user %ftp_user% &gt;&gt; %f_info%
echo %ftp_pass%&gt;&gt; %f_info%
echo prompt &gt;&gt; %f_info%
echo binary &gt;&gt; %f_info%
echo cd %ftp_path% &gt;&gt; %f_info%
echo ls . %f_list% &gt;&gt; %f_info%
echo lcd %f_tmp% &gt;&gt; %f_info%
echo disconnect &gt;&gt; %f_info%
echo bye &gt;&gt; %f_info%

ftp -v -n -s:%f_info%


for /f &quot;delims=&quot; %%i in (&#39;type &quot;%f_list%&quot;&#39;) do (
    set &quot;target_7z=%%i&quot;
)

echo open %ftp_ip% &gt; %f_info%
echo user %ftp_user% &gt;&gt; %f_info%
echo %ftp_pass%&gt;&gt; %f_info%
echo prompt &gt;&gt; %f_info%
echo binary &gt;&gt; %f_info%
echo cd %ftp_path% &gt;&gt; %f_info%
echo lcd %f_tmp% &gt;&gt; %f_info%
echo get %target_7z%&gt;&gt; %f_info%
echo disconnect &gt;&gt; %f_info%
echo bye &gt;&gt; %f_info%

ftp -v -n -s:%f_info%

call tools\7z\x64\7za.exe x %f_tmp%\%target_7z%

rd /s /q %f_tmp%

exit
</code></pre>
<p><img src="http://7xaw5u.com1.z0.glb.clouddn.com/windowsQQ%E6%88%AA%E5%9B%BE20151114170729.png" alt="运行脚本"></p>
<h3 id="逐步解释"><a href="#逐步解释" class="headerlink" title="逐步解释"></a>逐步解释</h3><h4 id="获取文件列表"><a href="#获取文件列表" class="headerlink" title="获取文件列表"></a>获取文件列表</h4><pre><code>echo open %ftp_ip% &gt; %f_info%
echo user %ftp_user% &gt;&gt; %f_info%
echo %ftp_pass%&gt;&gt; %f_info%
echo prompt &gt;&gt; %f_info%
echo binary &gt;&gt; %f_info%
echo cd %ftp_path% &gt;&gt; %f_info%
echo ls . %f_list% &gt;&gt; %f_info%
echo lcd %f_tmp% &gt;&gt; %f_info%
echo disconnect &gt;&gt; %f_info%
echo bye &gt;&gt; %f_info%

ftp -v -n -s:%f_info%
</code></pre>
<p>这部分代码主要有以下几个作用：</p>
<ol>
<li>将ftp的命令写入到文件；</li>
<li>在ftp上获取对应目录的文件列表，并写到本地文件下。</li>
</ol>
<h4 id="获取最新的一个文件"><a href="#获取最新的一个文件" class="headerlink" title="获取最新的一个文件"></a>获取最新的一个文件</h4><pre><code>for /f &quot;delims=&quot; %%i in (&#39;type &quot;%f_list%&quot;&#39;) do (
    set &quot;target_7z=%%i&quot;
)
</code></pre>
<p>然后循环遍历文件列表，最终获取到最后一个列表（也就是最新的文件名）。</p>
<h4 id="下载最新文件"><a href="#下载最新文件" class="headerlink" title="下载最新文件"></a>下载最新文件</h4><pre><code>echo open %ftp_ip% &gt; %f_info%
echo user %ftp_user% &gt;&gt; %f_info%
echo %ftp_pass%&gt;&gt; %f_info%
echo prompt &gt;&gt; %f_info%
echo binary &gt;&gt; %f_info%
echo cd %ftp_path% &gt;&gt; %f_info%
echo lcd %f_tmp% &gt;&gt; %f_info%
echo get %target_7z%&gt;&gt; %f_info%
echo disconnect &gt;&gt; %f_info%
echo bye &gt;&gt; %f_info%

ftp -v -n -s:%f_info%
</code></pre>
<p>有了文件名，我们就可以再执行一次ftp命令，下载我们最新的文件了。以上就实现了动态下载最新文件了。</p>
<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><p>这边我们使用的软件包是7z打包的。所以也要下载7z解压工具。<br>官方地址：<a target="_blank" rel="noopener" href="http://www.7-zip.org/">http://www.7-zip.org/</a><br>然后下载到命令行版，放置到任意可读取目录就可以了。</p>
<pre><code>call tools\7z\x64\7za.exe x %f_tmp%\%target_7z%
</code></pre>
<h3 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h3><p>平常习惯了在linux下倒腾。可以写些脚本做些繁琐的事情，但是在windows经常就傻眼了。可视化的东西是有很多好处，但是也有些弊端。批处理脚本虽然不好用，但也并不是不可用。很多时候也可以带来很大的方便。当然会python、ruby这些脚本语言其实也是完全可以满足的。毕竟现在这年头批处理这种东西用的越来越少了。<code>windows shell</code>也可以，但是感觉也不太好用。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a target="_blank" rel="noopener" href="http://occool.com/2012/03/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B7z/">http://occool.com/2012/03/【转载】命令行压缩解压7z/</a></li>
<li><a target="_blank" rel="noopener" href="http://www.robvanderwoude.com/ftp.php">http://www.robvanderwoude.com/ftp.php</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2015/11/05/501-Raspberrypi_Init/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ron">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ron的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/11/05/501-Raspberrypi_Init/" class="post-title-link" itemprop="url">[linux]树莓派入手体验和系统安装</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2015-11-05 20:00:00" itemprop="dateCreated datePublished" datetime="2015-11-05T20:00:00+08:00">2015-11-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="http://i.imgur.com/iAoxxbE.png" alt="树莓派"></p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>一直想捣鼓点什么东西。当看到树莓派的时候，就是它了。</p>
<p>树莓派可以安装<code>Linux</code>系统，而我在工作当中，可以说<code>Linux</code>是一半工作环境。树莓派真是个好东西，这个东西应该在我学习<code>linxu/Unix</code>的时候就该接触了。想想大学的时候，在<code>windows</code>下安装虚拟机，安装<code>Linux</code>是件多么痛苦的事情。而且那时的电脑配置也不算高，才2G内存，还要开虚拟机。玩个蛋蛋。</p>
<p>对<code>Linux</code>也算比较熟吧，入手一个树莓派应该可以玩很多好玩的事情。</p>
<h3 id="购买硬件"><a href="#购买硬件" class="headerlink" title="购买硬件"></a>购买硬件</h3><p>直接在某宝搜索入手。必须内容：</p>
<ul>
<li>树莓派一个（<code>Raspberry Pi 2</code>）</li>
<li>小usb口电源（5V2A的充电器随便找一个）</li>
<li>4G或者更大存储空间的SD卡一张（树莓派本身不带存储空间）</li>
</ul>
<p>以下非必需： </p>
<ul>
<li>散热器三片（风扇什么的觉得也太夸张了）</li>
<li>无线网卡（本身有网卡入口，所以不是必须的）</li>
<li>SD卡读卡器（安装系统的时候会用到）</li>
</ul>
<p><img src="http://i.imgur.com/0LQEdsC.jpg" alt="树莓派连接外置硬件"></p>
<h3 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h3><p>树莓派得到了各种<code>Linux</code>发行版本的支持，甚至微软在自己的<code>windows 10</code>上也发行了一个支持树莓派的版本。最常见的，还是在树莓派上面安装<code>RASPBIAN</code>和<code>Ubuntu</code>。<code>RASPBIAN</code>是树莓派官方出品基于<code>Debian</code>的<code>Linux</code>系统。也有喜欢在树莓派上面玩<code>windows 10</code>的。相关的系统官方都有提供下载。（<a target="_blank" rel="noopener" href="https://www.raspberrypi.org/downloads/" title="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a>）。</p>
<p>我本人安装的是官方提供的<code>RASPBIAN</code>系统，基于<code>Debian</code>实现。可以说对<code>Debian</code>比较了解，所以<code>RASPBIAN</code>对我来说是一个比较好的选择。以安装<code>RASPBIAN</code>为例，有多种安装方式。</p>
<p>树莓派官方推荐的是使用其官方工具<code>NOOBS</code>安装工具。</p>
<ol>
<li>下载<code>NOOBS</code>工具（<a target="_blank" rel="noopener" href="https://www.raspberrypi.org/downloads/noobs/" title="https://www.raspberrypi.org/downloads/noobs/">https://www.raspberrypi.org/downloads/noobs/</a>）；</li>
<li>下载SD卡格式化工具（<a target="_blank" rel="noopener" href="https://www.sdcard.org/downloads/formatter_4/eula_windows/">https://www.sdcard.org/downloads/formatter_4&#x2F;eula_windows&#x2F;</a>）；<ol>
<li>安装SD卡格式工具；</li>
<li>在选项Option里面设置“FORMAT SIZE ADJUSTMENT”为开启ON状态；</li>
<li>检查SD卡是否插入电脑；</li>
<li>点击格式化工具的【格式化(Format)】按钮格式化SD卡。</li>
</ol>
</li>
<li>解压NOOBS.zip文件；</li>
<li>将解压的文件复制到SD卡上面；</li>
<li>将SD卡插入到树莓派里面；</li>
<li>接上鼠标、键盘、显示器（这一部非必需）；</li>
<li>接上网线（无线网卡也可以）、电源，然后就自动开机启动了。</li>
</ol>
<p>开机启动后，树莓派会自行安装系统，看sd卡的写的速度时间会不一样，10~60分钟估计就好了。然后就会进入了树莓派的系统界面。至此，算是大功告成了。<br><img src="http://i.imgur.com/pHuni3O.jpg" alt="安装系统"></p>
<h4 id="关于系统"><a href="#关于系统" class="headerlink" title="关于系统"></a>关于系统</h4><p>树莓派官方系统<code>RASPBIAN</code>是基于<code>Debian</code>修改而来的。所以熟悉<code>Debian</code>和<code>Ubuntu</code>的话，对<code>RASPBIAN</code>是完全没有任何入门门槛的。<code>RASPBIAN</code>使用的是树莓派自己的镜像。其服务器在国外，访问起来可能有速度慢的情况，建议修改成网易的<code>Debian</code>镜像(<a target="_blank" rel="noopener" href="http://mirrors.163.com/.help/debian.html)%E3%80%82">http://mirrors.163.com/.help/debian.html)。</a><br>编辑&#x2F;etc&#x2F;apt&#x2F;sources.list文件, 在文件最前面添加以下条目(操作前请做好相应备份)</p>
<pre><code>deb http://mirrors.163.com/debian/ wheezy main non-free contrib
deb http://mirrors.163.com/debian/ wheezy-updates main non-free contrib
deb http://mirrors.163.com/debian/ wheezy-backports main non-free contrib
deb-src http://mirrors.163.com/debian/ wheezy main non-free contrib
deb-src http://mirrors.163.com/debian/ wheezy-updates main non-free contrib
deb-src http://mirrors.163.com/debian/ wheezy-backports main non-free contrib
deb http://mirrors.163.com/debian-security/ wheezy/updates main non-free contrib
deb-src http://mirrors.163.com/debian-security/ wheezy/updates main non-free contrib
</code></pre>
<p>执行<code>sudo apt-get update</code>更新软件包列表。详细可以查看网易<code>Debian</code>镜像的使用帮助（<a target="_blank" rel="noopener" href="http://mirrors.163.com/.help/debian.html%EF%BC%89%E3%80%82">http://mirrors.163.com/.help/debian.html）。</a></p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>树莓派最大的优势在于便宜，而且资料方面也算比较充足。个人觉得最大的价值还是拿来学习Linux的知识。独立的Linux机器，比起虚拟机，给人带来的学习积极性和成就感感觉是完全不一样的。当然，在可玩性方面，树莓派也可以做很多有趣的事情。倒腾飞行器、遥控玩具车、控制家庭电器、控制门禁、制作超级电脑等等。最主要的还是要有兴趣。而我，是想让树莓派来实现一些没有必要使用PC、需要长时间、或者定期任务的执行。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a target="_blank" rel="noopener" href="http://mirrors.163.com/.help/debian.html">http://mirrors.163.com/.help/debian.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.raspberrypi.org/help/quick-start-guide/">https://www.raspberrypi.org/help/quick-start-guide/</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2015/05/25/801-Game_Server_Design/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ron">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ron的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/05/25/801-Game_Server_Design/" class="post-title-link" itemprop="url">[game]游戏服务端的逻辑分服与物理分服</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2015-05-25 12:00:00" itemprop="dateCreated datePublished" datetime="2015-05-25T12:00:00+08:00">2015-05-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>工作室也经历过好几个游戏了。服务端的架构跟实际业务需求出现过不少的冲突。导致后来花了挺多时间去擦屁股的。以最近的一个游戏举例，原本的世界观设想是一个大服的世界观。也就是只有一个服，撑下百万用户，数万同时在线的设计。而后随着业务变化和线上表现，原本大服的设计并不能满足，最终变成了滚服玩法。由于大服变滚服，在原来的服务器架构约束下，对于后续增加的跨服玩法和合服实现都带来了比较大的麻烦和不少的工作量。</p>
<p><img src="http://i.imgur.com/SORhqLU.png" alt="物理分服和逻辑分服"></p>
<h3 id="物理分服"><a href="#物理分服" class="headerlink" title="物理分服"></a>物理分服</h3><p>原来的架构是按照大服设计的，所以在数据库上面的设计一个服对应一个数据库。假设我们滚了500个服，就需要建500个数据库，部署500个游戏服。无论后续跨服、合服的业务扩展，还是运维的维护方面，都变得比较复杂和困难。特别是合服的需求上面，需要将两个数据库甚至多个数据库合并成一个数据库。在量上来的时候，这一切都变得无比繁琐和复杂。开发人员也需要花费较多的人力和时间去写相应的工具。而且操作相对复杂，也比较容易出bug。而且后续新增的业务如果出现了持久化数据就需要增加相应的合服处理。</p>
<h3 id="逻辑分服"><a href="#逻辑分服" class="headerlink" title="逻辑分服"></a>逻辑分服</h3><p>如果说我们一开始就已经将数据库合并了呢，是不是后续根本就不需要去合并数据库了。所以如果在当初框架设计的时候就已经按照逻辑来分服的话，后续的事情处理起来就简单多了。问过同行业的一些游戏架构，他们也是这么处理的。</p>
<h4 id="对于合服"><a href="#对于合服" class="headerlink" title="对于合服"></a>对于合服</h4><p>因为数据其实还是在同一个库里面，而且也是在同一个服务器里面。只要简单处理，或者甚至不需要任何处理，就可以将两个或多个服合并。只需要在后台设置一下入口配置、可见配置就可以解决合服的问题了。</p>
<h4 id="对于跨服"><a href="#对于跨服" class="headerlink" title="对于跨服"></a>对于跨服</h4><p>跨服原本的问题就是需要从不同库读取数据和与不同服进行交互。如果本身就不存在多服的问题，也不存在跨服的问题。</p>
<p>虽然逻辑分服可以比较完美解决合服的问题，但是对于跨服还是需要单独处理。毕竟如果一个逻辑分服的服务器真的扛不住的时候，就会出现真的物理分服。对于跨服的需求来说，可能都是需要跨的。</p>
<h4 id="维护成本"><a href="#维护成本" class="headerlink" title="维护成本"></a>维护成本</h4><p>相对于物理分服，逻辑分服可以极大地降低运维成本。数据库数量级可以极大减少，服务器数量也可以减少。对于备份、更新等运维操作都相对变得简单。甚至可以不依赖于运维工具，就可以简单地维护机器了。一台机器部署一个服(多个逻辑服)对比一台机器部署多个游戏服(一个逻辑服)，需要初始化的内存一般来说会变小(不排除不一样的情况)，机器的资源占用一般来说会小很多。所以对物理机的利用效率可以提高很多。</p>
<h4 id="用户数量级的问题"><a href="#用户数量级的问题" class="headerlink" title="用户数量级的问题"></a>用户数量级的问题</h4><p>逻辑分服必然会出现性能瓶颈，不可避免地出现了物理分服、分库的情况。而对于合服来说，合服本身就是发生在用户数量或者同时在线数量不足的情况下出现的。如果用户数量过大，基本上不太可能出现合服的需求。如果前期量级大，已经物理分服了。后期量级小了，其实重新叠回去也不是什么大的问题。只需要跟运营沟通好了，还是可以使用逻辑分服的事情去解决合服的事情。当然如果运营需要真的在不同物理服上面进行合服，我也没有想到比较好的办法，只能又苦逼地去处理的样子。</p>
<h4 id="开发成本"><a href="#开发成本" class="headerlink" title="开发成本"></a>开发成本</h4><p>由于逻辑分服，的确是增加了一些内容，譬如玩家所在的服务器ID。但是这个处理起来并没有多大的难度，而且对key值也并没有多大的影响。</p>
<p>逻辑分服的架构对于大世界和滚服都是支持的，只是对于大世界的话，就浪费了一个存储空间和一点点内存。但是这样的框架可以自如应对大世界到滚服之间的变化。如果一开始就按照大世界来设计，万一某一天滚服了，就要麻烦地多。</p>
<p>所以逻辑分服并不会提升多大的开发成本。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2015/04/28/401-Deploy_Tmux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ron">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ron的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/04/28/401-Deploy_Tmux/" class="post-title-link" itemprop="url">[linux]CentOS下安装和使用tmux</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2015-04-28 18:27:54" itemprop="dateCreated datePublished" datetime="2015-04-28T18:27:54+08:00">2015-04-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前天随意点开博客园，看到了一篇关于tmux的文章 <a target="_blank" rel="noopener" href="http://cenalulu.github.io/linux/tmux/">Tmux - Linux从业者必备利器</a>，特意还点进去看了。毕竟Linux对于做游戏服务端开发的我来说，太熟悉不过了。不过我就粗略地看了一眼，就关掉了。直到第二天<code>码农周刊</code>就推荐了这篇文章，才引起我真正的关注。<code>tmux</code>真的那么好用吗？所以我自己也倒腾来一遍，的确在许多场景下还是非常有用的。如：</p>
<ul>
<li>做服务器的，肯定需要关注性能的，而tmux多个pane可以很方便同时关注多项性能指标；</li>
<li>我们的游戏服刚好有多个服务存在，而联调多个服务的时候，可以同时看到多个控制台确实很方便。</li>
</ul>
<p>以上并不是其它方式不可以，譬如我用xshell的，同时看多个xshell可以达到相同的效果。但切换的时候还是有些不方便。 因为环境不同，原作者用Mac，而我用CentOS，有些地方存在不一样，故记载方便自己以后查阅。</p>
<h3 id="CentOS下安装"><a href="#CentOS下安装" class="headerlink" title="CentOS下安装"></a>CentOS下安装</h3><p>首先我是用<code>yum install tmux</code>尝试安装的。估计没有源，没有找到tmux。所以习惯性直接找源代码安装。<br>但是其中有依赖，需要先安装<code>libevent</code>。</p>
<pre><code>wget https://github.com/downloads/libevent/libevent/libevent-2.0.21-stable.tar.gz
tar xzvf libevent-2.0.21-stable.tar.gz
cd libevent-2.0.21-stable
./configure &amp;&amp; make
make install
</code></pre>
<p>然后再下载源码安装tmux</p>
<pre><code>git clone git://git.code.sf.net/p/tmux/tmux-code tmux
cd tmux
sh autogen.sh
./configure &amp;&amp; make
make install
</code></pre>
<p>过程中遇到了两个报错，解决都比较简单，当然是查阅资料后。</p>
<h4 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h4><p>期间我遇到了执行autogen.sh 报错，原因是我没有安装automake。这个直接<code>yum install automake</code>就简单解决了。</p>
<h4 id="问题2："><a href="#问题2：" class="headerlink" title="问题2："></a>问题2：</h4><p>执行的时候遇到</p>
<pre><code>libevent-2.0.so.5: cannot open shared object file: No such file or directory
</code></pre>
<p>的报错，解决办法也比较简单，既然找不到，那就换个找得到的地方呗。</p>
<pre><code>ln -s /usr/local/lib/libevent-2.0.so.5 /usr/lib/libevent-2.0.so.5     # 32位系统
ln -s /usr/local/lib/libevent-2.0.so.5 /usr/lib64/libevent-2.0.so.5   # 64位系统
</code></pre>
<h3 id="使用和快捷键"><a href="#使用和快捷键" class="headerlink" title="使用和快捷键"></a>使用和快捷键</h3><p>直接在命令行输入tmux即可进入tmux的模式。</p>
<p>tmux主要有windows窗体操作和Pane操作，个人觉得windows对于我来说，意义不大(并不是说windows模式没适用场景)，所以这里主要讲下Pane的相关操作。</p>
<h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>tmux的快捷键都要先按<code>C-b(Ctrl-b)</code>。然后再按下面表格内容，才能达到相应的效果。</p>
<h4 id="session和其他相关快捷键"><a href="#session和其他相关快捷键" class="headerlink" title="session和其他相关快捷键"></a>session和其他相关快捷键</h4><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">C-z</td>
<td align="left">关闭tmux.</td>
</tr>
<tr>
<td align="center">:</td>
<td align="left">进入tmux命令行模式.</td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">列出所有快捷键.</td>
</tr>
<tr>
<td align="center">t</td>
<td align="left"><strong>显示时间.</strong></td>
</tr>
<tr>
<td align="center">d</td>
<td align="left">退出当前tmux客户端，tmux后台运行.</td>
</tr>
</tbody></table>
<pre><code>   | 
</code></pre>
<p> $     | 重命名当前session.<br> s     | <strong>切换session 显示所有session并切换到某一个session.</strong><br> (     | 切换session 切换到上一个session.<br> )     | 切换session 切换到下一个session.<br> L     | 切换session 到前一个活跃的session.</p>
<h4 id="window相关快捷键"><a href="#window相关快捷键" class="headerlink" title="window相关快捷键"></a>window相关快捷键</h4><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">c</td>
<td align="left"><strong>新增一个window.</strong></td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="left">退出当前window.</td>
</tr>
<tr>
<td align="center">,</td>
<td align="left">重命名当前window.</td>
</tr>
<tr>
<td align="center">l</td>
<td align="left">跳转到上一个所在window.</td>
</tr>
</tbody></table>
<pre><code>    | 
</code></pre>
<p> i      | 显示当前window的信息.<br> w      | <strong>切换window 显示所有window并切换window.</strong><br> 0 to 9 | 切换window 到相应编号的window.<br> p      | 切换window 上一个window.<br> n      | 切换window 下一个window.<br> ’      | 切换window 到输入编号的window.<br> f      | 切换window 到搜索到的window.<br> Space  | 改变当前window下的pane布局.</p>
<h4 id="pane相关快捷键"><a href="#pane相关快捷键" class="headerlink" title="pane相关快捷键"></a>pane相关快捷键</h4><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">!</td>
<td align="left"><strong>从window移除当前pane.</strong></td>
</tr>
<tr>
<td align="center">“</td>
<td align="left"><strong>将当前pane变成上下两个pane.</strong></td>
</tr>
<tr>
<td align="center">%</td>
<td align="left"><strong>将当前pane变成左右两个pane.</strong></td>
</tr>
<tr>
<td align="center">x</td>
<td align="left"><strong>关闭当前pane.</strong></td>
</tr>
<tr>
<td align="center">q</td>
<td align="left">显示pane的索引.</td>
</tr>
<tr>
<td align="center">z</td>
<td align="left"><strong>最大化或者恢复当前pane.</strong></td>
</tr>
<tr>
<td align="center">{</td>
<td align="left">跟前一个pane交换位置.</td>
</tr>
<tr>
<td align="center">}</td>
<td align="left">跟后一个pane交换位置.</td>
</tr>
<tr>
<td align="center">o</td>
<td align="left">切换Pane 到下一个pane.</td>
</tr>
<tr>
<td align="center">;</td>
<td align="left"><strong>切换Pane 进入到前一个操作过的pane.</strong></td>
</tr>
<tr>
<td align="center">Up, Down Left, Right</td>
<td align="left">切换Pane 使用方向键切换到相应方向的pane.</td>
</tr>
</tbody></table>
<p>可能有些快捷键有些出入，可以的话提醒下。另外有些快捷键没有搞懂，而且快捷键比较多，个人觉得记得主要的几个切换快捷键就足够用来。比较tmux只是一个协助工具，没有必要在其上面那么用心。加粗的是个人觉得比较实用的。</p>
<p>tmux不中断session的模式确实很666666，每次连回去就可以快速接上上次结束的环境。而且多个pane也非常适合要开启并监控多个服务的情况。</p>
<p><img src="http://i.imgur.com/guRsWo3.png" alt="多个pane例子"></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a target="_blank" rel="noopener" href="http://cenalulu.github.io/linux/tmux/" title="Tmux - Linux从业者必备利器">http://cenalulu.github.io/linux/tmux/</a></li>
<li><a target="_blank" rel="noopener" href="http://elroyjetson.org/dev-notes/centos/installing-tmux-on-centos-6-2" title="Installing tmux on CentOS 6.2">http://elroyjetson.org/dev-notes/centos/installing-tmux-on-centos-6-2</a></li>
<li><a target="_blank" rel="noopener" href="http://www.nigeldunn.com/2011/12/11/libevent-2-0-so-5-cannot-open-shared-object-file-no-such-file-or-directory/" title="libevent-2.0.so.5: cannot open shared object file: No such file or directory">http://www.nigeldunn.com/2011/12/11/libevent-2-0-so-5-cannot-open-shared-object-file-no-such-file-or-directory/</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2015/04/07/402-Stop_Selinux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ron">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ron的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/04/07/402-Stop_Selinux/" class="post-title-link" itemprop="url">[linux]windows无法访问samba的安全性问题(关闭selinux)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2015-04-07 18:00:00" itemprop="dateCreated datePublished" datetime="2015-04-07T18:00:00+08:00">2015-04-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在某一天重启了虚拟机的 <code>linux</code> 之后，我的 <code>windows</code> 在连接上 <code>samba</code> 之后，点击某些文件夹的时候，会出现没有权限打开的情况。这问题折腾了我一度重新配置了好几次 <code>samba</code> 的配置，然而无果。</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>经过搜索，发现有两个办法可以解决samba的某些文件夹无法访问的问题。</p>
<ul>
<li>方法一 修改文件和文件夹的安全策略；</li>
<li>方法二 关闭 <code>selinux</code>；</li>
</ul>
<p>第一种方法并不合适，只是临时解决的一种方案。因为在 <code>windows</code> 下新建了一个 <code>linux</code> 文件夹之后，下一次重启了 <code>linux</code> ，新的文件夹又无法访问了。麻烦。第二种方法就简单了，一劳永逸。</p>
<p>虽然网上又说关闭 <code>selinux</code> 会有安全问题。然而只是我虚拟机的 <code>linux</code> 开发机而已，并不是生产环境，没有太高的安全问题。</p>
<h4 id="方法一-修改安全策略"><a href="#方法一-修改安全策略" class="headerlink" title="方法一 修改安全策略"></a>方法一 修改安全策略</h4><pre><code> chcon -t samba_share_t share
</code></pre>
<p>chcon 可以修改文件的安全上下文。重置windows建立的文件、文件夹的安全信息。也可以解决，但是比较麻烦，不方便。</p>
<h4 id="方法二-关闭-selinux"><a href="#方法二-关闭-selinux" class="headerlink" title="方法二 关闭 selinux"></a>方法二 关闭 selinux</h4><h5 id="永久关闭"><a href="#永久关闭" class="headerlink" title="永久关闭"></a>永久关闭</h5><p>修改 <code>/etc/selinux/config</code> 文件，设置</p>
<pre><code>SELINUX=disabled
</code></pre>
<p>然后重启linux。</p>
<h5 id="临时关闭"><a href="#临时关闭" class="headerlink" title="临时关闭"></a>临时关闭</h5><p>使用 <code>setenforce</code> 命令可以修改 <code>selinux</code> 模式。</p>
<ul>
<li><code>setenforce 1</code> 设置 <code>selinux</code> 为 <code>enforcing</code> 模式；</li>
<li><code>setenforce 0</code> 设置 <code>selinux</code> 为 <code>permissive</code> 模式。</li>
</ul>
<h4 id="其它方案"><a href="#其它方案" class="headerlink" title="其它方案"></a>其它方案</h4><p><a target="_blank" rel="noopener" href="https://wiki.centos.org/zh/HowTos/SetUpSamba" title="https://wiki.centos.org/zh/HowTos/SetUpSamba">https://wiki.centos.org/zh/HowTos/SetUpSamba</a> 有相当详细的解释和解决办法。有时间折腾的可以看看。</p>
<p>以上。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ron</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ron</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
